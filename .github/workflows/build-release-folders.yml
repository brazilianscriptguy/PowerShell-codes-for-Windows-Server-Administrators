# .github/workflows/build-release-folders.yml
# Build and Release Workflow for Ubuntu-SysAdmin-ProSuite
name: Build and Release

on:
  workflow_dispatch:    # Allows manual triggering of the workflow
  release:
    types: [published]  # Triggers when a release is published

permissions:
  contents: write       # Allows creating and modifying releases

jobs:
  build-and-release:
    runs-on: ubuntu-latest    # Changed from windows-latest to ubuntu-latest

    steps:
      # Step 1: Check out the repository, including submodules if any
      - name: Checkout repository
        uses: actions/checkout@v3    # Updated to v3
        with:
          submodules: true           # Set to true if using Git submodules

      # Step 2: Install Dependencies
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zip

      # Step 3: Build and package artifacts
      - name: Build and package artifacts
        id: package
        run: |
          # Create the main folder 'PowerShellCodes'
          mkdir -p PowerShellCodes

          # Copy LICENSE and README.md to 'PowerShellCodes'
          cp LICENSE PowerShellCodes/ || true
          cp README.md PowerShellCodes/ || true

          # Iterate over all subdirectories (sub-repositories) in the main repository
          for dir in */ ; do
              dir=${dir%/}  # Remove trailing slash
              if [[ "$dir" != "PowerShellCodes" && "$dir" != ".git" ]]; then
                  mkdir -p PowerShellCodes/"$dir"
                  cp -r "$dir"/* PowerShellCodes/"$dir"/ || true
              fi
          done

          # Locate and copy 'Launch-Script-AutomaticMenu.ps1' into 'PowerShellCodes'
          source_file="Core-ScriptLibrary/Launch-Script-AutomaticMenu.ps1"
          if [[ -f "$source_file" ]]; then
              cp "$source_file" PowerShellCodes/ || true
          else
              echo "File $source_file not found. Aborting workflow."
              exit 1
          fi

          # Compress the 'PowerShellCodes' folder into a ZIP file
          zip -r Package-ProSuite.zip PowerShellCodes

          # Output the path to the ZIP file for later steps
          package_path=$(pwd)/Package-ProSuite.zip
          echo "package-path=$package_path" >> $GITHUB_OUTPUT

      # Step 4: Compute SHA256 hash of the package
      - name: Compute SHA256 hash
        id: compute_hash
        run: |
          hash=$(sha256sum "${{ steps.package.outputs.package-path }}" | awk '{print $1}')
          echo "hash=$hash" >> $GITHUB_OUTPUT

      # Step 5: Upload the package as a GitHub Release asset (Only on Release Events)
      - name: Upload Release Asset
        if: github.event_name == 'release' && github.event.action == 'published'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ${{ steps.package.outputs.package-path }}
          asset_name: Package-ProSuite.zip
          asset_content_type: application/zip

      # Step 6: Update release notes with the SHA256 hash (Only on Release Events)
      - name: Update Release Notes with SHA256 Hash
        if: github.event_name == 'release' && github.event.action == 'published' && steps.compute_hash.outputs.hash != ''
        uses: actions/github-script@v6    # Updated to v6
        with:
          script: |
            const hash = '${{ steps.compute_hash.outputs.hash }}';
            const releaseId = context.payload.release.id;
            const currentBody = context.payload.release.body || '';
            const updatedBody = `${currentBody}\n\n**SHA256 Hash of Package-ProSuite.zip:** \`${hash}\``;
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              body: updatedBody
            });
